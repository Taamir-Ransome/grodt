# Story 1.2: Trade Entry

## Status
Draft

## Story
**As a** trading strategy,
**I want** to execute a market buy order when an uptrend is confirmed and a market sell order when a downtrend is confirmed,
**so that** I can enter positions based on the trend identification signals from the VWAP and EMA indicators

## Acceptance Criteria
1. A buy order is placed when price > VWAP AND price > EMA.
2. A sell order is placed when price < VWAP AND price < EMA.
3. Orders are routed through the execution engine.
4. The position size is calculated based on the ATR-based stop distance defined in the risk management system.

## Tasks / Subtasks
- [ ] Task 1: Implement trade signal generation (AC: 1, 2)
  - [ ] Create trade signal service that consumes trend detection from Story 1.1
  - [ ] Implement buy signal logic: price > VWAP AND price > EMA
  - [ ] Implement sell signal logic: price < VWAP AND price < EMA
  - [ ] Add signal validation to prevent conflicting signals
- [ ] Task 2: Integrate with execution engine (AC: 3)
  - [ ] Create order placement service that interfaces with execution engine
  - [ ] Implement market buy order creation and submission
  - [ ] Implement market sell order creation and submission
  - [ ] Add order status tracking and confirmation handling
- [ ] Task 3: Integrate with risk management for position sizing (AC: 4)
  - [ ] Connect to risk management system for ATR-based stop distance calculation
  - [ ] Implement position size calculation based on ATR stop distance
  - [ ] Add position size validation against risk limits
  - [ ] Integrate position sizing with order quantity calculation
- [ ] Task 4: Add unit tests for all components
  - [ ] Test trade signal generation logic
  - [ ] Test order creation and submission
  - [ ] Test position sizing calculations
  - [ ] Test integration between components

## Dev Notes

### Previous Story Insights
From Story 1.1 completion:
- Trend detection is working with VWAPCalculator, EMACalculator, and TrendDetector classes
- All trend identification logic is implemented and tested (17 tests, 100% pass rate)
- Data flow is established: WebSocket → Data Layer → 1-minute OHLCV bars → Trend Detection
- The system can identify "up" and "down" trends based on price vs VWAP and EMA

### Data Models
[Source: architecture/data-architecture.md#database-schema]
- orders table: Tracks order lifecycle (id, client_order_id, status, symbol, quantity, submit_timestamp, fill_timestamp)
- trades table: Records filled trades (id, timestamp, symbol, side, price, quantity)
- positions table: Maintains current portfolio positions (symbol, quantity, average_entry_price)
- equity_curve table: Stores portfolio value timeseries (timestamp, portfolio_value)

### API Specifications
[Source: architecture/system-overview-logical-architecture.md#api-connectors]
- API Connectors manage communication with Robinhood API (WebSocket for real-time data, REST for orders)
- Execution Engine acts on signals from Strategy Engine, constructs and places orders, manages order lifecycle (NEW → ACK → PARTIAL → FILLED / CANCELED)
- Orders flow: Strategy Engine → Execution Engine → API Connectors → Robinhood API

### Component Specifications
[Source: architecture/component-deep-dive.md#execution-engine]
- Execution Engine: Features a finite state machine for order tracking (NEW → ACK → PARTIAL → FILLED / CANCELED)
- Risk Management: Calculates position sizes based on ATR-based stop distance, checks against global limits (daily_loss_cap, max_positions) defined in risk.yaml
- Strategy Interface: Base class with required methods (on_bar(bar_data), on_fill(fill_data)) - S1 strategy is first implementation

### File Locations
Based on project structure analysis:
- Execution Engine: `grodtd/execution/engine.py` (existing file)
- Risk Management: `grodtd/risk/manager.py` (existing file)
- Strategy Engine: `grodtd/strategies/` directory
- API Connectors: `grodtd/connectors/robinhood.py` (existing file)
- Configuration: `configs/risk.yaml` (existing file)

### Testing Requirements
No specific guidance found in architecture docs for testing standards, frameworks, or patterns. Standard Python testing practices should be followed with unit tests in the `tests/` directory.

### Technical Constraints
[Source: architecture/architectural-goals-constraints.md]
- Performance: System must handle real-time market data and execute orders with low latency to minimize slippage
- Reliability: System must be resilient to failures, including API disconnects and unexpected errors
- Testability: Architecture supports comprehensive testing from unit tests to end-to-end validation
- Modularity: Components are decoupled allowing independent development and testing

### Project Structure Notes
The current project structure aligns with the architecture:
- `grodtd/execution/engine.py` exists for execution engine
- `grodtd/risk/manager.py` exists for risk management
- `grodtd/connectors/robinhood.py` exists for API connectors
- `grodtd/strategies/` exists for strategy implementations
- `configs/risk.yaml` exists for risk configuration

## Testing
No specific testing standards found in architecture documents. Standard Python testing practices should be followed with unit tests in the `tests/` directory.

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|---------|
| 2025-01-27 | 1.0 | Initial story creation | Bob (Scrum Master) |

## Dev Agent Record

### Agent Model Used
*To be populated by development agent*

### Debug Log References
*To be populated by development agent*

### Completion Notes List
*To be populated by development agent*

### File List
*To be populated by development agent*

## QA Results
*To be populated by QA agent*
